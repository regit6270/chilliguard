import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../blocs/soil_health/soil_health_bloc.dart';
import '../../widgets/common/bottom_navigation_bar.dart';
import '../../widgets/common/loading_overlay.dart';
import '../../widgets/soil_health/comparison_card_widget.dart';
import '../../widgets/soil_health/duration_selector.dart';
import '../../widgets/soil_health/parameter_selector.dart';
import '../../widgets/soil_health/stat_card.dart';

class SoilHealthScreen extends StatefulWidget {
  const SoilHealthScreen({super.key});

  @override
  State<SoilHealthScreen> createState() => _SoilHealthScreenState();
}

class _SoilHealthScreenState extends State<SoilHealthScreen> {
  @override
  void initState() {
    super.initState();
    _loadSoilHealth();
  }

  void _loadSoilHealth() {
    print('üîç [Screen] Triggering LoadSoilHealthData event');
    const fieldId = 'field_123'; // TODO: Get from LocalStorageService
    context.read<SoilHealthBloc>().add(
          const LoadSoilHealthData(fieldId: fieldId, duration: '7d'),
        );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Soil Health'),
        actions: [
          IconButton(
            icon: const Icon(Icons.info_outline),
            tooltip: 'Learn About Soil Health',
            onPressed: () => context.push('/knowledge-base/soil-health'),
          ),
        ],
      ),
      body: BlocBuilder<SoilHealthBloc, SoilHealthState>(
        builder: (context, state) {
          print('üîç [Screen] BLocBuilder state: ${state.runtimeType}');

          if (state is SoilHealthLoading) {
            return const LoadingOverlay(message: 'Loading soil data...');
          }

          if (state is SoilHealthError) {
            return _buildErrorView(state.message);
          }

          if (state is SoilHealthLoaded) {
            print(
                '‚úÖ [Screen] SoilHealthLoaded - ${state.readings.length} readings');
            return RefreshIndicator(
              onRefresh: () async {
                context.read<SoilHealthBloc>().add(
                      const LoadSoilHealthData(
                        fieldId: 'field_123',
                        duration: '7d',
                      ),
                    );
                await Future.delayed(const Duration(milliseconds: 500));
              },
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Duration Selector
                    DurationSelector(
                      selectedDuration: state.selectedDuration,
                      onDurationChanged: (duration) {
                        context.read<SoilHealthBloc>().add(
                              ChangeDuration(duration),
                            );
                      },
                    ),
                    const SizedBox(height: 20),

                    // ‚úÖ FIXED: Statistics Cards with Dynamic Aspect Ratio
                    if (state.latestReading != null) _buildStatsGrid(state),
                    const SizedBox(height: 24),

                    // Parameter Selector
                    Text(
                      'Parameter Trends',
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                    const SizedBox(height: 12),
                    ParameterSelector(
                      selectedParameter: state.selectedParameter,
                      onParameterChanged: (parameter) {
                        context.read<SoilHealthBloc>().add(
                              ChangeParameter(parameter),
                            );
                      },
                    ),
                    const SizedBox(height: 20),

                    // Section Header
                    Text(
                      'Yesterday vs. Today',
                      style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Track daily changes in selected parameter',
                      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                            color: Colors.grey[600],
                          ),
                    ),
                    const SizedBox(height: 16),

                    // ‚úÖ NEW: Yesterday vs Today Comparison Card (Selected Parameter Only)
                    _buildComparisonCard(state),
                    const SizedBox(height: 24),

                    // Analysis Summary
                    _buildAnalysisSummary(state),
                    const SizedBox(height: 80), // Bottom nav padding
                  ],
                ),
              ),
            );
          }

          return const Center(child: Text('Unknown state'));
        },
      ),
      bottomNavigationBar:
          const ChilliGuardBottomNavigationBar(currentIndex: 1),
    );
  }

  // ‚úÖ FIXED: Dynamic aspect ratio calculation
  Widget _buildStatsGrid(SoilHealthLoaded state) {
    final screenWidth = MediaQuery.of(context).size.width;

    // Calculate optimal aspect ratio based on screen width
    // Formula: (screenWidth - totalPadding) / 3 columns / desiredCardHeight
    const totalHorizontalPadding =
        16 * 2 + 12 * 2; // Screen padding + grid spacing
    final cardWidth = (screenWidth - totalHorizontalPadding) / 3;
    const desiredCardHeight = 100.0; // Base card height
    final calculatedAspectRatio = cardWidth / desiredCardHeight;

    // Clamp between 0.9 and 1.6 for safety
    final safeAspectRatio = calculatedAspectRatio.clamp(0.9, 1.6);

    return GridView.count(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: 3,
      mainAxisSpacing: 12,
      crossAxisSpacing: 12,
      childAspectRatio: safeAspectRatio, // ‚úÖ DYNAMIC CALCULATION
      children: [
        StatCard(
          label: 'Current',
          value: _getCurrentValue(state),
          color: Colors.blue,
          icon: Icons.show_chart,
        ),
        StatCard(
          label: 'Average',
          value: _getAverageValue(state),
          color: Colors.green,
          icon: Icons.analytics,
        ),
        StatCard(
          label: 'Range',
          value: _getRangeValue(state),
          color: Colors.orange,
          icon: Icons.swap_vert,
        ),
      ],
    );
  }

  String _getCurrentValue(SoilHealthLoaded state) {
    final reading = state.latestReading!;
    switch (state.selectedParameter) {
      case 'ph':
        return reading.ph.toStringAsFixed(1);
      case 'nitrogen':
        return '${reading.nitrogen.toStringAsFixed(0)} ppm';
      case 'phosphorus':
        return '${reading.phosphorus.toStringAsFixed(0)} ppm';
      case 'potassium':
        return '${reading.potassium.toStringAsFixed(0)} ppm';
      case 'moisture':
        return '${reading.moisture.toStringAsFixed(0)}%';
      case 'temperature':
        return '${reading.temperature.toStringAsFixed(1)}¬∞C';
      default:
        return 'N/A';
    }
  }

  String _getAverageValue(SoilHealthLoaded state) {
    final avg = state.averages[state.selectedParameter] ?? 0;
    switch (state.selectedParameter) {
      case 'ph':
        return avg.toStringAsFixed(1);
      case 'nitrogen':
      case 'phosphorus':
      case 'potassium':
        return '${avg.toStringAsFixed(0)} ppm';
      case 'moisture':
        return '${avg.toStringAsFixed(0)}%';
      case 'temperature':
        return '${avg.toStringAsFixed(1)}¬∞C';
      default:
        return 'N/A';
    }
  }

  String _getRangeValue(SoilHealthLoaded state) {
    if (state.readings.isEmpty) return 'N/A';

    final parameter = state.selectedParameter;
    double minVal = double.infinity;
    double maxVal = double.negativeInfinity;

    for (final reading in state.readings) {
      double value;
      switch (parameter) {
        case 'ph':
          value = reading.ph;
          break;
        case 'nitrogen':
          value = reading.nitrogen;
          break;
        case 'phosphorus':
          value = reading.phosphorus;
          break;
        case 'potassium':
          value = reading.potassium;
          break;
        case 'moisture':
          value = reading.moisture;
          break;
        case 'temperature':
          value = reading.temperature;
          break;
        default:
          value = 0;
      }

      if (value < minVal) minVal = value;
      if (value > maxVal) maxVal = value;
    }

    return '${minVal.toStringAsFixed(1)}-${maxVal.toStringAsFixed(1)}';
  }

  // ‚úÖ NEW: Build Yesterday vs Today Comparison Card (Selected Parameter Only)
  Widget _buildComparisonCard(SoilHealthLoaded state) {
    if (state.readings.isEmpty) {
      return Container(
        padding: const EdgeInsets.all(24),
        alignment: Alignment.center,
        child: Column(
          children: [
            Icon(Icons.inbox_outlined, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text(
              'No comparison data available',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
      );
    }

    // Extract yesterday and today values
    final comparisonData = _extractYesterdayTodayValues(state.readings);

    if (comparisonData == null) {
      return Container(
        padding: const EdgeInsets.all(24),
        alignment: Alignment.center,
        child: Column(
          children: [
            Icon(Icons.history, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text(
              'Need at least 2 days of data for comparison',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey[600],
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      );
    }

    final yesterday = comparisonData['yesterday']!;
    final today = comparisonData['today']!;

    // Get parameter details based on selection
    final parameterInfo = _getParameterInfo(state.selectedParameter);

    return ComparisonCard(
      parameterName: parameterInfo['name'] as String,
      unit: parameterInfo['unit'] as String,
      yesterdayValue: _getParameterValue(yesterday, state.selectedParameter),
      todayValue: _getParameterValue(today, state.selectedParameter),
      parameterIcon: parameterInfo['icon'] as IconData,
      optimalRange: parameterInfo['range'] as String,
    );
  }

  // Helper: Get parameter-specific information
  Map<String, dynamic> _getParameterInfo(String parameter) {
    switch (parameter) {
      case 'ph':
        return {
          'name': 'pH Level',
          'unit': '',
          'icon': Icons.science_outlined,
          'range': '5.5 - 7.5',
        };
      case 'nitrogen':
        return {
          'name': 'Nitrogen',
          'unit': ' ppm',
          'icon': Icons.grass_outlined,
          'range': '100 - 150 ppm',
        };
      case 'phosphorus':
        return {
          'name': 'Phosphorus',
          'unit': ' ppm',
          'icon': Icons.spa_outlined,
          'range': '50 - 75 ppm',
        };
      case 'potassium':
        return {
          'name': 'Potassium',
          'unit': ' ppm',
          'icon': Icons.local_florist_outlined,
          'range': '50 - 100 ppm',
        };
      case 'moisture':
        return {
          'name': 'Moisture',
          'unit': '%',
          'icon': Icons.water_drop_outlined,
          'range': '60 - 70%',
        };
      case 'temperature':
        return {
          'name': 'Temperature',
          'unit': '¬∞C',
          'icon': Icons.thermostat_outlined,
          'range': '20 - 30¬∞C',
        };
      default:
        return {
          'name': 'Unknown',
          'unit': '',
          'icon': Icons.help_outline,
          'range': 'N/A',
        };
    }
  }

  // Helper: Extract specific parameter value from reading
  double _getParameterValue(dynamic reading, String parameter) {
    switch (parameter) {
      case 'ph':
        return reading.ph;
      case 'nitrogen':
        return reading.nitrogen;
      case 'phosphorus':
        return reading.phosphorus;
      case 'potassium':
        return reading.potassium;
      case 'moisture':
        return reading.moisture;
      case 'temperature':
        return reading.temperature;
      default:
        return 0.0;
    }
  }

  // ‚úÖ FIXED: Extract yesterday and today readings safely with type safety
  Map<String, dynamic>? _extractYesterdayTodayValues(List<dynamic> readings) {
    if (readings.length < 2) return null;

    try {
      // Sort readings by timestamp (newest first)
      final sortedReadings = List.from(readings)
        ..sort((a, b) {
          try {
            return (b as dynamic).timestamp.compareTo((a as dynamic).timestamp);
          } catch (e) {
            return 0; // If comparison fails, maintain order
          }
        });

      // Get today's reading (most recent)
      final todayReading = sortedReadings.first;

      // Find yesterday's reading (24 hours ago, with ¬±12 hour tolerance)
      final todayDate = (todayReading as dynamic).timestamp as DateTime;
      final yesterdayTarget = todayDate.subtract(const Duration(hours: 24));

      dynamic yesterdayReading;
      Duration minDifference =
          const Duration(days: 365); // Initialize with large value

      for (final reading in sortedReadings) {
        try {
          final readingTimestamp = (reading as dynamic).timestamp as DateTime;
          final difference =
              (readingTimestamp.difference(yesterdayTarget)).abs();

          // Find reading closest to 24 hours ago
          if (difference < minDifference) {
            minDifference = difference;
            yesterdayReading = reading;
          }
        } catch (e) {
          // Skip readings with invalid timestamps
          continue;
        }
      }

      // Ensure we found a valid yesterday reading (within 12-hour tolerance)
      if (yesterdayReading == null ||
          minDifference > const Duration(hours: 12)) {
        return null;
      }

      return {
        'yesterday': yesterdayReading,
        'today': todayReading,
      };
    } catch (e) {
      // Return null if any error occurs during extraction
      return null;
    }
  }

  // ‚úÖ RESTORED: Analysis Summary Section
  Widget _buildAnalysisSummary(SoilHealthLoaded state) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.blue[50],
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.blue[200]!),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.insights, color: Colors.blue[700]),
              const SizedBox(width: 8),
              Text(
                'Analysis',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  color: Colors.blue[900],
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            _getAnalysisText(state),
            style: TextStyle(
              fontSize: 14,
              color: Colors.blue[800],
              height: 1.5,
            ),
          ),
          const SizedBox(height: 12),
          ElevatedButton.icon(
            onPressed: () => context.push('/soil-improvement-recommendations'),
            icon: const Icon(Icons.lightbulb_outline, size: 18),
            label: const Text('View Recommendations'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blue[700],
              foregroundColor: Colors.white,
            ),
          ),
        ],
      ),
    );
  }

  String _getAnalysisText(SoilHealthLoaded state) {
    final parameter = state.selectedParameter;
    final avg = state.averages[parameter] ?? 0;

    switch (parameter) {
      case 'ph':
        if (avg >= 5.5 && avg <= 7.5) {
          return 'Your soil pH is in the optimal range for chilli cultivation (5.5-7.5). Maintain current practices.';
        } else if (avg < 5.5) {
          return 'Soil pH is slightly acidic. Consider applying lime to raise pH for better chilli growth.';
        } else {
          return 'Soil pH is slightly alkaline. Consider applying sulfur to lower pH for optimal nutrient availability.';
        }
      case 'nitrogen':
        if (avg >= 100 && avg <= 150) {
          return 'Nitrogen levels are optimal for chilli growth. Continue with current fertilization schedule.';
        } else if (avg < 100) {
          return 'Nitrogen is below optimal levels. Apply urea (50 kg/ha) or compost to boost nitrogen content.';
        } else {
          return 'Nitrogen is high. Reduce fertilizer application to prevent excessive vegetative growth.';
        }
      case 'phosphorus':
        if (avg >= 50 && avg <= 75) {
          return 'Phosphorus levels are optimal. Good for root development and flowering.';
        } else if (avg < 50) {
          return 'Phosphorus is low. Consider applying SSP or DAP fertilizer.';
        } else {
          return 'Phosphorus is high. Reduce phosphate fertilizer application.';
        }
      case 'potassium':
        if (avg >= 50 && avg <= 100) {
          return 'Potassium levels are optimal. Good for fruit quality and disease resistance.';
        } else if (avg < 50) {
          return 'Potassium is low. Apply MOP (Muriate of Potash) to boost levels.';
        } else {
          return 'Potassium is high. Reduce potash application.';
        }
      case 'moisture':
        if (avg >= 60 && avg <= 70) {
          return 'Soil moisture is optimal. Maintain current irrigation schedule.';
        } else if (avg < 60) {
          return 'Soil moisture is low. Increase irrigation frequency and consider mulching to retain moisture.';
        } else {
          return 'Soil moisture is high. Improve drainage and reduce irrigation to prevent root diseases.';
        }
      case 'temperature':
        if (avg >= 20 && avg <= 30) {
          return 'Soil temperature is optimal for chilli growth (20-30¬∞C).';
        } else if (avg < 20) {
          return 'Soil temperature is low. Consider using black mulch to increase temperature.';
        } else {
          return 'Soil temperature is high. Use organic mulch to cool the soil.';
        }
      default:
        return 'Monitor this parameter regularly for optimal crop health.';
    }
  }

  Widget _buildErrorView(String message) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.error_outline, size: 64, color: Colors.red[300]),
          const SizedBox(height: 16),
          const Text(
            'Error Loading Soil Health',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 32),
            child: Text(
              message,
              textAlign: TextAlign.center,
              style: TextStyle(color: Colors.grey[600]),
            ),
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: _loadSoilHealth,
            icon: const Icon(Icons.refresh),
            label: const Text('Retry'),
          ),
        ],
      ),
    );
  }
}
